# ================================
# ğŸ“Œ DÃ©finition du Deployment
# ================================
apiVersion: apps/v1 # SpÃ©cifie la version de l'API Kubernetes utilisÃ©e pour les Deployments.
kind: Deployment # Indique que nous dÃ©finissons un Deployment (gÃ¨re la crÃ©ation et la mise Ã  jour des Pods).

metadata:
  name: client-depl # Nom du Deployment, utilisÃ© pour l'identifier dans le cluster.

spec:
  replicas: 1 # Nombre de Pods identiques Ã  exÃ©cuter (ici, un seul Pod).

  selector:
    matchLabels:
      app: client # SÃ©lectionne les Pods qui ont le label "app: client" pour les gÃ©rer avec ce Deployment.

  template: # ModÃ¨le utilisÃ© pour crÃ©er les Pods.
    metadata:
      labels:
        app: client # Assigne le label "app: client" aux Pods crÃ©Ã©s pour qu'ils soient sÃ©lectionnÃ©s correctement.

    spec:
      containers:
        - name: client # Nom du conteneur (utile pour le monitoring et la gestion).
          image: elbraco/client # Image Docker utilisÃ©e pour ce conteneur (doit Ãªtre disponible sur Docker Hub ou un registre privÃ©).
          # âš ï¸ Assurez-vous que l'image "elbraco/client" est bien disponible pour Ã©viter les erreurs de dÃ©ploiement.
---
# ================================
# ğŸ“Œ DÃ©finition du Service
# ================================
apiVersion: v1 # SpÃ©cifie que nous dÃ©finissons un Service Kubernetes.
kind: Service # Indique que nous crÃ©ons un Service pour exposer le Pod.

metadata:
  name: client-srv # Nom du Service, utilisÃ© pour l'identifier dans le cluster.

spec:
  selector:
    app: client # Associe ce Service aux Pods ayant le label "app: client" (crÃ©Ã©s par le Deployment ci-dessus).

  ports:
    - name: client # Nom du port (facultatif, utile pour le monitoring et l'organisation).
      protocol: TCP # Utilisation du protocole TCP (par dÃ©faut pour HTTP).
      port: 3000 # Port exposÃ© par le Service (autres services du cluster peuvent l'utiliser pour accÃ©der Ã  client).
      targetPort: 3000 # Port sur lequel lâ€™application Ã©coute Ã  lâ€™intÃ©rieur du Pod.

# ================================
# ğŸ“– Explication du fonctionnement
# ================================

# Ce fichier YAML dÃ©finit deux objets dans Kubernetes :
# 1ï¸âƒ£ Un **Deployment** (`client-depl`) qui crÃ©e et gÃ¨re un Pod avec un conteneur basÃ© sur `elbraco/client`.
# 2ï¸âƒ£ Un **Service** (`client-srv`) qui expose le Pod et permet aux autres services du cluster dâ€™y accÃ©der via `client-srv:3000`.

# ğŸš€ Fonctionnement :
# - Le Deployment assure que le Pod "client" est toujours en cours d'exÃ©cution.
# - Si le Pod crash, Kubernetes le recrÃ©e automatiquement.
# - Le Service agit comme un point d'entrÃ©e stable pour communiquer avec l'application d'cliententification.
# - Les autres services du cluster peuvent contacter l'cliententification via `http://client-srv:3000` sans se soucier de l'IP du Pod.

# ğŸ”— Exemple de requÃªte :
# - Un autre service peut appeler lâ€™cliententification avec `curl http://client-srv:3000/login`.

# ğŸ”¥ Avantages :
# âœ… Le Service garantit une communication stable mÃªme si les Pods redÃ©marrent.
# âœ… Si `replicas: 1` est augmentÃ©, Kubernetes Ã©quilibrera automatiquement la charge entre les Pods.
# âœ… Kubernetes gÃ¨re la haute disponibilitÃ© et le redÃ©marrage automatique en cas de crash.

# ğŸ› ï¸ Prochaine Ã©tape :
# - Tester le dÃ©ploiement avec `kubectl apply -f client.yaml`
# - VÃ©rifier que le Pod tourne avec `kubectl get pods`
# - VÃ©rifier que le Service est accessible avec `kubectl get services`

# Client (Navigateur, API)
#    â†’ RequÃªte HTTP vers "tickets.dev/api/users/login"
#    â†’ Ingress Controller (nginx)
#    â†’ Service "client-srv"
#    â†’ Pod "client" (conteneur elbraco/client)
#    â†’ RÃ©ponse retournÃ©e au client
